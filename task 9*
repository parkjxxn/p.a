// Розглянемо процес переходу від цілого x до цілого y вздовж цілих точок прямої. Довжина кожного кроку має бути невід’ємною та бути або на одиницю більшою, або дорівнювати, або на одиницю меншою за довжину попереднього кроку. Довжина першого і останнього кроків повинна бути 1.

// Створіть функцію, яка обчислює мінімальну кількість кроків, необхідних для переходу від x до y. Він повинен обробляти 0 <= x <= y < 2 31 .

// Один з підходів до розв'язання цієї задачі може використовувати рекурсію. Можемо створити функцію, яка обчислює мінімальну кількість кроків для переходу від x до y

// Ідея полягає в тому, що кожен крок може бути або на 1 більший, або на 1 менший за попередній крок. Таким чином, ми можемо рекурсивно обчислити мінімальну кількість кроків, використовуючи формулу:

// minSteps(x, y) = 1 + min(minSteps(x+1, y), minSteps(x-1, y)) , де x+1 та x-1 представляють наступні можливі кроки.

// Однак, для ефективності, ми можемо використовувати динамічне програмування

#include <stdio.h>

int minSteps(int x, int y) {
    int dp[100000] = {0}; // Ініціалізуємо масив dp нулями

    for (int i = x + 1; i <= y; i++) {
        dp[i] = 1 + dp[i - 1]; // Ініціалізуємо dp[i] значенням на одиницю більше, ніж попереднє
        if (i % 2 == 0) {
            dp[i] = dp[i / 2] < dp[i] ? dp[i / 2] : dp[i]; // Перевіряємо, чи можемо зробити крок в 2 рази менший
        }
    }

    return dp[y];
}

int main() {
    int x, y;
    printf("Введіть x: ");
    scanf("%d", &x);
    printf("Введіть y: ");
    scanf("%d", &y);

    int result = minSteps(x, y);
    printf("Мінімальна кількість кроків: %d\n", result);

    return 0;
}
